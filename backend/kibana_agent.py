import os
import json
import uuid
import requests
from typing import Dict, Any, List, Literal
from pydantic import BaseModel, Field
from langchain_openai import ChatOpenAI
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

class Visualization(BaseModel):
    title: str = Field(description="The visualization title")
    type: List[Literal["pie", "metric", "table","line", "area", "histogram"]] = Field(description="The type(s) of visualization")
    field: str = Field(description="The field that this visualization uses based on the provided mappings")

class Dashboard(BaseModel):
    title: str = Field(description="The dashboard title")
    visualizations: List[Visualization]

def init_chat_model(model_name: str = "gpt-4o-mini"):
    """Initialize OpenAI chat model with API key from environment"""
    api_key = os.getenv('OPENAI_API_KEY')
    if not api_key:
        raise ValueError("OPENAI_API_KEY not found in environment variables. Please add it to your .env file.")
    
    return ChatOpenAI(
        model=model_name,
        api_key=api_key,
        temperature=0
    )

def generate_dashboard_from_text(description: str, index_mappings: str) -> Dashboard:
    """Generate dashboard configuration from text description"""
    
    prompt = f"""
    You are an expert in creating Kibana dashboards for version 8.11 of Kibana.
    You will be given a text description of what the user wants in their dashboard and an Elasticsearch index mapping.
    
    Below are the index mappings for the index that the dashboard will be based on:
    Index Mappings:
    {index_mappings}
    
    Based on the user's description, create a dashboard with appropriate visualizations.
    Only use fields that exist in the provided index mappings.
    Choose visualization types that make sense for the data being displayed.
    
    User's dashboard description:
    {description}
    
    Create a dashboard with visualizations that best represent what the user is asking for.
    """
    
    try:
        llm = init_chat_model()
        llm_with_structure = llm.with_structured_output(Dashboard)
        
        dashboard_values = llm_with_structure.invoke(prompt)
        print("Dashboard values generated by the LLM successfully")
        print(dashboard_values)
        return dashboard_values
        
    except Exception as e:
        print(f"Failed to analyze description and generate dashboard: {str(e)}")
        raise

def fill_template_with_analysis(
    template: Dict[str, Any],
    visualization: Visualization,
    grid_data: Dict[str, Any],
) -> Dict[str, Any]:
    """Fill visualization template with generated analysis data"""
    template_str = json.dumps(template)
    replacements = {
        "{visualization_id}": str(uuid.uuid4()),
        "{title}": visualization.title,
        "{x}": grid_data["x"],
        "{y}": grid_data["y"],
    }
    
    if visualization.field:
        replacements["{field}"] = visualization.field
    
    for placeholder, value in replacements.items():
        template_str = template_str.replace(placeholder, str(value))
    
    return json.loads(template_str)

def check_elasticsearch_connection(kibana_url: str = None):
    """Check if Elasticsearch/Kibana is accessible and get version info"""
    kibana_url = kibana_url or os.getenv('KIBANA_URL', 'http://localhost:5601')
    
    try:
        # Test Kibana connection (no auth needed)
        headers = {"kbn-xsrf": "true"}
        response = requests.get(f"{kibana_url}/api/status", headers=headers, timeout=10)
        
        if response.status_code == 200:
            print("âœ… Kibana is accessible")
            try:
                status_data = response.json()
                version = status_data.get('version', {}).get('number', 'unknown')
                print(f"ðŸ“Š Kibana version: {version}")
            except:
                print("ðŸ“Š Kibana version: Could not determine")
            return True
        else:
            print(f"âŒ Kibana returned status code: {response.status_code}")
            print(f"Response: {response.text}")
            return False
            
    except requests.exceptions.ConnectionError:
        print("âŒ Cannot connect to Kibana. Make sure your Docker containers are running.")
        print("Try: docker ps | grep -E '(elastic|kibana)'")
        return False
    except Exception as e:
        print(f"âŒ Error connecting to Kibana: {e}")
        return False

def test_kibana_api_endpoints(kibana_url: str):
    """Test different Kibana API endpoints to find the correct one"""
    headers = {"Content-Type": "application/json", "kbn-xsrf": "true"}
    
    # Test basic API access first
    basic_endpoints = [
        "/api/saved_objects/_find?type=dashboard&per_page=1",
        "/api/saved_objects/dashboard",
        "/api/status"
    ]
    
    print("ðŸ” Testing Kibana API access...")
    
    for endpoint in basic_endpoints:
        try:
            test_url = f"{kibana_url}{endpoint}"
            response = requests.get(test_url, headers=headers, timeout=5)
            print(f"  GET {endpoint}: Status {response.status_code}")
            
            if response.status_code == 200 and "saved_objects" in endpoint:
                print("âœ… Saved Objects API is accessible")
                return "/api/saved_objects/dashboard"
                
        except Exception as e:
            print(f"  {endpoint}: Error - {e}")
    
    return "/api/saved_objects/dashboard"  # Default to this for Kibana 8.x

def create_kibana_dashboard(
    dashboard_values: Dashboard, 
    templates: Dict[str, Dict],
    kibana_url: str = None
) -> tuple[str, str]:
    """Create dashboard in Kibana with visualizations and return URL + ID"""
    
    kibana_url = kibana_url or os.getenv('KIBANA_URL', 'http://localhost:5601')
    headers = {"Content-Type": "application/json", "kbn-xsrf": "true"}
    
    dashboard_id = str(uuid.uuid4())
    panels = []
    y = 0

    # 1. Create visualizations in Kibana
    for idx, viz in enumerate(dashboard_values.visualizations, start=1):
        viz_id = str(uuid.uuid4())
        vis_config = {
            "attributes": {
                "title": viz.title,
                "visState": json.dumps({
                    "title": viz.title,
                    "type": viz.type[0],  # pick first type
                    "aggs": [
                        {"id": "1", "enabled": True, "type": "count", "schema": "metric"},
                        {
                            "id": "2",
                            "enabled": True,
                            "type": "terms",
                            "schema": "segment",
                            "params": {"field": viz.field, "size": 10}
                        }
                    ]
                }),
                "uiStateJSON": "{}",
                "version": 1,
                "kibanaSavedObjectMeta": {
                    "searchSourceJSON": json.dumps({"query": {"match_all": {}}, "filter": []})
                }
            }
        }
        
        # POST visualization
        resp = requests.post(
            f"{kibana_url}/api/saved_objects/visualization/{viz_id}",
            headers=headers,
            json=vis_config
        )
        if resp.status_code not in [200, 201]:
            raise Exception(f"Failed to create visualization: {resp.text}")
        
        # Add panel reference
        panels.append({
            "panelIndex": str(idx),
            "gridData": {"x": 0, "y": y, "w": 24, "h": 15, "i": str(idx)},
            "version": "8.11.0",
            "type": "visualization",
            "id": viz_id
        })
        y += 15  # stack charts vertically

    # 2. Create dashboard with those panels
    dashboard_config = {
        "attributes": {
            "title": dashboard_values.title,
            "description": "Generated by AI from text description",
            "panelsJSON": json.dumps(panels),
            "optionsJSON": json.dumps({
                "useMargins": True,
                "syncColors": False,
                "hidePanelTitles": False
            }),
            "version": 1,
            "timeRestore": False,
            "kibanaSavedObjectMeta": {
                "searchSourceJSON": json.dumps({"query": {"match_all": {}}, "filter": []})
            }
        }
    }

    resp = requests.post(
        f"{kibana_url}/api/saved_objects/dashboard/{dashboard_id}",
        headers=headers,
        json=dashboard_config
    )
    if resp.status_code not in [200, 201]:
        raise Exception(f"Failed to create dashboard: {resp.text}")

    dashboard_url = f"{kibana_url}/app/dashboards#/view/{dashboard_id}"
    print("âœ… Dashboard created:", dashboard_url)
    return dashboard_url, dashboard_id


def main(description: str, index_mappings: str, templates: Dict[str, Dict]):
    """Main function to generate dashboard from text description"""
    try:
        # Check connection first
        if not check_elasticsearch_connection():
            print("\nðŸš€ To start your Elasticsearch/Kibana Docker setup:")
            print("docker-compose up -d")
            print("Or if using individual containers:")
            print("docker run -d --name elasticsearch -p 9200:9200 -e 'discovery.type=single-node' -e 'xpack.security.enabled=false' docker.elastic.co/elasticsearch/elasticsearch:8.11.0")
            print("docker run -d --name kibana -p 5601:5601 --link elasticsearch docker.elastic.co/kibana/kibana:8.11.0")
            return {
                "success": False,
                "error": "Cannot connect to Kibana"
            }
        
        # Generate dashboard configuration from text description
        dashboard_values = generate_dashboard_from_text(description, index_mappings)
        
        # Create the dashboard in Kibana
        dashboard_url, dashboard_id = create_kibana_dashboard(dashboard_values, templates)
        
        return {
            "success": True,
            "dashboard_url": dashboard_url,
            "dashboard_id": dashboard_id,
            "dashboard_config": dashboard_values
        }
        
    except Exception as e:
        return {
            "success": False,
            "error": str(e)
        }

# Example usage:
if __name__ == "__main__":
    # Example index mappings (replace with your actual mappings)
    example_mappings = """
    {
        "properties": {
            "duration": {"type": "integer"},
            "protocol_type": {"type": "keyword"},
            "service": {"type": "keyword"},
            "label": {"type": "keyword"},
            "timestamp": {"type": "date"}
        }
    }
    """
    
    # Example templates (you'll need to provide your actual templates)
    example_templates = {
        "bar": {"type": "bar_chart", "template": "your_bar_template"},
        "pie": {"type": "pie_chart", "template": "your_pie_template"},
        "metric": {"type": "metric", "template": "your_metric_template"}
    }
    
    # Example description
    description = input("Enter your dashboard description: ")
    
    result = main(description, example_mappings, example_templates)
    print("Result:", result)